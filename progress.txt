# Ralph Progress Log
Started: Wed Jan 28 04:56:36 HKT 2026
---

## [2025-01-28] - US-001
- Created src/types/pattern.ts with Pattern, PatternCategory, Difficulty, and CodeSnippet types
- Types provide structure for pattern metadata including id, title, description, path, category, difficulty, and code snippets
- Build and typecheck passed
- **Learnings for future iterations:**
  - Existing types are in src/types/ (e.g., navigation.ts) - pattern types follow this convention
  - Build command `npm run build` handles TypeScript checking - no separate typecheck script configured
  - Existing NavigationRoute interface has similar structure to Pattern - consider if Pattern should extend or be separate
---

## [2025-01-28] - US-002
- Created src/lib/patterns-data.ts with PATTERN_CATEGORIES export
- Defined 12 categories with id, title, icon (emoji), and description
- Categories: ScrollTrigger Basics, Horizontal Scroll, Text Animations, Parallax & Depth, Page Transitions, Micro-interactions, Timelines, SVG Animations, Draggable, Advanced Scroll, Performance, Real-world Examples
- Added helper functions: getCategoryById(), CATEGORY_GROUPS, CATEGORY_COUNT
- Build and typecheck passed
- **Learnings for future iterations:**
  - Category IDs use kebab-case for consistency with URL routing
  - Emojis are used for icons for simplicity (e.g., ðŸ“œ for ScrollTrigger Basics)
  - Helper functions like getCategoryById() are useful for data access patterns
  - CATEGORY_GROUPS const provides logical grouping by difficulty level
  - Using 'as const' assertion on CATEGORY_GROUPS for type safety
---

## [2025-01-28] - US-003
- Created src/app/patterns/fade-reveal/page.tsx as the entry point for the pattern page
- Created src/components/patterns/fade-reveal-pattern.tsx with full implementation
- Pattern page structure: Header (title, description, badges), Live Demo (6 animated cards), Code Viewer (syntax highlighted), Key Concepts (4 explanation cards), Footer CTA
- Live demo uses gsap.set() for initial state (opacity: 0, y: 60) and gsap.to() with stagger: 0.15 for fade reveal animation
- Code viewer includes inline syntax-highlighted JSX using colored span elements
- Copy to clipboard button with visual feedback (scan line effect on hover, "Copied!" state)
- Proper cleanup in useGSAP return function: gsap.killTweensOf(elements)
- Follows industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accent
- Visual motifs: corner accents, diagonal stripe decorations, scan line effects, grid pattern overlays
- Build and typecheck passed, browser verified
- **Learnings for future iterations:**
  - Pattern pages should follow this structure: Header â†’ Live Demo â†’ Code Viewer â†’ Key Concepts â†’ CTA
  - Use separate span elements for syntax highlighting rather than complex nested braces to avoid JSX parsing issues
  - The scan line animation uses @keyframes scan defined in globals.css with animate-scan class
  - Grid pattern overlays use the grid-pattern-overlay class from globals.css
  - Code viewer should include a "Copied!" state with timeout reset for better UX
  - useGSAP cleanup should call gsap.killTweensOf() with the same selector used for animation
---

## [2025-01-28] - US-004
- Created src/app/patterns/scale-reveal/page.tsx as the entry point for the scale reveal pattern page
- Created src/components/patterns/scale-reveal-pattern.tsx with full implementation
- Scale reveal pattern: elements scale up from 0.8 to 1 with elastic.out(1, 0.5) easing
- Live demo uses gsap.set() for initial state (scale: 0.8, opacity: 0) and gsap.to() with stagger: 0.12
- Elastic easing creates spring-like bounce effect with overshoot: first param (1) controls amplitude, second (0.5) controls decay
- Code viewer with syntax-highlighted TypeScript/JSX code showing scale animation pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: gsap.killTweensOf(cards) in useGSAP return function
- 6 demo cards explaining elastic easing concepts: ELASTIC EASING, SCALE RANGE, OVERSHOOT, OSCILLATION, COMBINE WITH FADE, PERFORMANCE
- 4 key concept cards explaining: elastic easing parameters, duration importance, scale start point, combining animations
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents, corner accents, diagonal stripes
- Build and typecheck passed, browser verified
- **Learnings for future iterations:**
  - Elastic easing needs more time (0.8s+) than other easings to complete the bounce animation
  - Starting scale at 0.8 creates room for the overshoot effect (can go up to ~1.05)
  - Scale animations are GPU-accelerated and very performant - good choice for many elements
  - Elastic.out(1, 0.5) parameters: first is amplitude (overshoot), second is decay (settle speed)
  - Scale works beautifully combined with opacity fade for enhanced depth perception
---
## [2025-01-28] - US-005
- Created src/app/patterns/staggered-reveal/page.tsx as the entry point for the staggered reveal pattern page
- Created src/components/patterns/staggered-reveal-pattern.tsx with full implementation
- Staggered reveal pattern: elements slide in from left (x: -100 to 0) with 0.15s stagger delay between each
- Live demo uses gsap.set() for initial state (x: -100, opacity: 0) and gsap.to() with stagger: 0.15, power2.out easing
- power2.out easing provides smooth deceleration that feels natural for slide-in effects
- Code viewer with syntax-highlighted TypeScript/JSX code showing stagger animation pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: gsap.killTweensOf(cards) in useGSAP return function
- 8 demo cards in 4-column grid explaining stagger concepts: STAGGER DELAY, SEQUENCE ORDER, SLIDE DIRECTION, FADE COMBINATION, EASING CHOICE, GRID LAYOUTS, TIMING CONTROL, LARGE COLLECTIONS
- 4 key concept cards explaining: stagger value, direction control, grid layouts, advanced stagger options (from, grid)
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents, corner accents, diagonal stripes
- Build and typecheck passed, browser verified
- **Learnings for future iterations:**
  - Stagger delay of 0.15s creates a balanced cascade - lower (0.1) for faster, higher (0.3) for more dramatic effects
  - x: -100 creates left-to-right slide-in; x: 100 creates right-to-left; y for vertical movement
  - Stagger naturally follows DOM order in CSS Grid - left to right, top to bottom
  - Advanced stagger object form: { each: 0.15, from: "center" } or { from: "edges", grid: [rows, cols] }
  - power2.out is excellent for slide animations - smooth deceleration feels more natural than linear
---

## [2025-01-28] - US-006
- Created src/app/patterns/batch-reveal/page.tsx as the entry point for the batch reveal pattern page
- Created src/components/patterns/batch-reveal-pattern.tsx with full implementation
- Batch reveal pattern: 24 items animate with grid-based stagger starting from center
- Live demo uses gsap.set() for initial state (scale: 0.9, opacity: 0) and gsap.to() with stagger: { amount: 0.8, from: "center", grid: [4, 6] }
- Grid-based stagger enables spatial animation patterns that animate outward from a specific point
- Code viewer with syntax-highlighted TypeScript/JSX code showing batch animation pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: gsap.killTweensOf(items) in useGSAP return function
- 24 demo items in 6-column responsive grid (2/3/4/6 columns across breakpoints)
- 4 key concept cards explaining: grid-based stagger, amount vs each, GPU acceleration, performance tips
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- **Learnings for future iterations:**
  - stagger: { amount: 0.8 } distributes total time across all items, ensuring consistent timing regardless of count
  - grid: [rows, cols] tells GSAP about your layout, enabling "from: center" and other spatial stagger patterns
  - Scale and opacity are GPU-accelerated properties - always prefer them over layout properties for smooth animations
  - For 50+ items, use smaller amounts (0.3-0.5s) or consider staggering by rows/cols for different effects
  - When writing JSX code in template strings, escape curly braces like {`)})`} to avoid parsing errors
---

## [2025-01-28] - US-007
- Created src/app/patterns/char-text-reveal/page.tsx as the entry point for the character text reveal pattern
- Created src/components/patterns/char-text-reveal-pattern.tsx with full implementation
- Character-by-character text reveal: splits text into inline-block spans, then animates with stagger
- Live demo uses gsap.set() for initial state (y: 100, opacity: 0) and gsap.to() with stagger: 0.03
- back.out(1.7) easing creates spring-like overshoot - each character "bounces" into place
- splitText() helper function: text.split('') creates array, map() wraps each char in span with inline-block
- Space handling: char === ' ' ? '\u00A0' : char preserves spacing (non-breaking space for whitespace)
- Hero text: "KINETIC" in white, "TYPOGRAPHY" with orange-amber gradient
- Two demo cards showing "Quick Reveal" and "Spring Effect" variations
- 4 key concept cards explaining: inline-block requirement, stagger value tuning, back.out easing, space handling
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed, browser verified
- **Learnings for future iterations:**
  - Character spans MUST have inline-block display for y-axis transforms to work (inline would ignore vertical translation)
  - Stagger value of 0.03 (30ms per char) creates fast, smooth character reveals - adjust 0.02-0.05 for different speeds
  - back.out(1.7) parameters: 1.7 is the overshoot amount - higher = more bounce, lower = more subtle
  - Spaces collapse in inline flex layouts - use \u00A0 (non-breaking space) or &nbsp; to preserve spacing
  - For text with gradients, use bg-gradient-to-r with bg-clip-text and text-transparent classes
---
## [2025-01-28] - US-008
- Created src/app/patterns/word-text-reveal/page.tsx as the entry point for the word text reveal pattern
- Created src/components/patterns/word-text-reveal-pattern.tsx with full implementation
- Word-by-word text reveal: splits text by spaces into inline-block spans, then animates with stagger
- Live demo uses gsap.set() for initial state (y: 50, opacity: 0) and gsap.to() with stagger: 0.15
- power2.out easing provides smooth deceleration that feels natural for word animations
- splitText() helper function: text.split(' ') creates array, map() wraps each word in span with inline-block and whitespace-nowrap
- Whitespace preservation: {i < arr.length - 1 && ' '} pattern adds spaces back after each word except the last
- Hero text: "WORD BY WORD REVEAL ANIMATION" in uppercase
- Four demo cards showing variations: "Capture Attention", "Create Impact", "Tell Your Story", "Engage Users"
- 4 key concept cards explaining: word-level splitting, stagger value tuning, whitespace preservation, power2.out easing
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed, browser verified (24 word-reveal elements found on page)
- **Learnings for future iterations:**
  - Word spans need inline-block AND whitespace-nowrap to prevent words from breaking across lines during animation
  - Stagger value of 0.15 (150ms per word) creates dramatic word reveals - larger than character reveals (0.03) since fewer elements
  - When using .split(' '), spaces are removed and must be added back with conditional rendering
  - The pattern {i < arr.length - 1 && ' '} adds space after all words except the last to avoid trailing space
  - power2.out is ideal for word animations - smooth deceleration feels more polished than back.out for text
  - Dev server was running on port 3000 from a different directory - used PORT=3001 for correct project
---
## [2025-01-28] - US-009
- Created src/app/patterns/text-fill/page.tsx as the entry point for the text fill animation pattern
- Created src/components/patterns/text-fill-pattern.tsx with full implementation
- Text fill animation: uses background-clip: text technique with animated backgroundPosition
- Live demo animates backgroundPosition from 0% to 100% as user scrolls, creating a color-fill effect
- Gradient is set to 200% width (bg-[length:200%_auto]) to allow the fill animation to work
- Uses scrub: 1 in ScrollTrigger for smooth scroll-linked animation with power2.inOut easing
- Hero text: "SCROLL TO FILL" with orange-amber gradient
- Four demo cards showing gradient variations: orange (vibrant), fire (multi-stop), cool (cyan-blue), sunset (pink-purple-indigo)
- 4 key concept cards explaining: background-clip: text, 200% background size, scrub animation, background-position
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed, browser verified
- **Learnings for future iterations:**
  - The background-clip: text technique requires text-transparent and bg-clip-text classes to work
  - Set bg-[length:200%_auto] to make the gradient twice as wide as the text, enabling the fill animation
  - backgroundPosition: '0% 50%' shows the start of the gradient (gray/transparent), '100% 50%' shows the end (full color)
  - scrub: 1 creates smooth scroll-linked animation with 1 second of "catch up" lag for polished feel
  - power2.inOut provides smooth acceleration and deceleration - ideal for fill effects
  - Multi-stop gradients (via-orange-500 via-amber-500) create richer color transitions
  - The initial style={{ backgroundPosition: '0% 50%' }} is critical - without it, the text starts already filled
---
## [2025-01-28] - US-010
- Created src/app/patterns/simple-parallax/page.tsx as the entry point for the simple parallax pattern page
- Created src/components/patterns/simple-parallax-pattern.tsx with full implementation
- Simple parallax pattern: background moves at 50% speed (y: -200) while foreground moves at normal speed (y: 50)
- Live demo uses gsap.to() with scrub: true for scroll-linked animation and ease: 'none' for direct 1:1 relationship
- Background has grid pattern overlay and "BG" text, foreground has centered card with orange accent corners
- Speed ratio of 0.5 creates convincing depth perception - background moves upward (-200px) while foreground moves slightly downward (50px)
- Code viewer with syntax-highlighted TypeScript/JSX code showing parallax animation pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: gsap.killTweensOf(background) and gsap.killTweensOf(foreground) in useGSAP return function
- 3 info cards showing: Speed Ratio (0.5), Y-Translation (-200px), Scrub Mode (true)
- 4 key concept cards explaining: speed ratio (0.5 = 50% speed), scrub: true (direct scroll link), y-axis movement (opposite directions), ease: "none" (no easing for parallax)
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- **Learnings for future iterations:**
  - Parallax requires moving layers at different speeds - use y translation with scrub: true
  - Background should move opposite to scroll direction (negative y) while foreground can move with scroll (positive y) or stay stable
  - Always use ease: "none" for parallax - easing would break the direct 1:1 scroll relationship
  - Speed ratio of 0.3-0.5 creates subtle depth, 0.1-0.2 creates dramatic depth (but can cause dizziness)
  - For multi-layer parallax, use different y values for each layer: far (0.2), mid (0.5), near (1.0)
  - scrub: true makes animation reversible - scrolling back up plays the animation in reverse
  - The parallax container needs explicit height (e.g., h-[600px]) to have scroll distance for the effect
---

## [2025-01-28] - US-011
- Created src/app/patterns/multi-layer-parallax/page.tsx as the entry point for the multi-layer parallax pattern
- Created src/components/patterns/multi-layer-parallax-pattern.tsx with full implementation
- Multi-layer parallax pattern: 3 layers moving at progressive speeds create immersive 3D depth effect
- Layer 1 (Background): 0.2x speed, y: -100, z-index: 10, "FAR" text with 10% opacity
- Layer 2 (Mid-ground): 0.5x speed, y: -50, z-index: 20, "MID" text with floating geometric shapes
- Layer 3 (Foreground): 1.0x speed, y: 50, z-index: 30, "DEPTH" card with full opacity
- Uses scrub: true for scroll-linked animation and ease: 'none' for direct 1:1 relationship
- Code viewer with syntax-highlighted TypeScript/JSX code showing multi-layer parallax pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: gsap.killTweensOf() for all three layers in useGSAP return function
- 3 speed comparison cards showing: Background (0.2x), Mid-Ground (0.5x), Foreground (1.0x)
- 4 key concept cards explaining: z-index layering, speed gradients, opacity variations, movement direction
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: agent-browser skill was unavailable for this session - manual browser verification recommended
- **Learnings for future iterations:**
  - Z-index layering is critical for multi-layer parallax: use progressive values (10/20/30) for proper stacking
  - Progressive speed ratios (0.2x, 0.5x, 1.0x) create convincing depth - larger gaps = more pronounced 3D effect
  - Opacity variations enhance atmospheric perspective: distant layers (10%), mid-layers (30%), foreground (100%)
  - Background and mid-ground should move upward (negative y) while foreground can move downward (positive y) for contrast
  - Container height of 700px provides sufficient scroll distance for the parallax effect to be noticeable
  - Each layer needs a unique class name (.parallax-layer-bg, .parallax-layer-mid, .parallax-layer-fg) for GSAP targeting

## [2025-01-28] - US-012
- Created src/app/patterns/button-hover/page.tsx as the entry point for the button hover pattern
- Created src/components/patterns/button-hover-pattern.tsx with full implementation
- Button hover pattern: Three interactive button styles using mouseenter/mouseleave events
- Scale+Shadow: Uses back.out(1.7) elastic easing with scale: 1.05 and animated boxShadow (0 4px â†’ 0 20px 40px with orange glow)
- Magnetic: Uses gsap.quickTo() for high-performance cursor tracking - button follows mouse with 0.3x magnetic strength
- Icon Animation: Combines subtle button scale (1.02) with icon translate (x: 8) and rotate (45deg) for playful effect
- Proper event listener cleanup: removeEventListener() + gsap.killTweensOf() in useGSAP return function
- Live demo section with 3 cards showing each button style with emoji icons and descriptive labels
- Code viewer with syntax-highlighted TypeScript/JSX code
- Copy to clipboard button with scan line hover effect
- 4 key concept cards explaining: hover events (mouseenter vs mouseover), quickTo performance, cleanup importance, easing choices
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed, browser verified
- **Learnings for future iterations:**
  - mouseenter/mouseleave don't bubble - use these instead of mouseover/mouseout for hover effects to prevent unwanted animations
  - gsap.quickTo() creates cached, performant tweens ideal for high-frequency updates like mouse tracking - much faster than gsap.to() in mousemove
  - For magnetic effects, calculate mouse offset from center: (mouse - center) * strength, where 0.2-0.5 is typical strength range
  - back.out(1.7) creates playful overshoot for CTAs - the 1.7 value controls bounce amount (higher = more bounce)
  - power2.out is professional and smooth - use for more conservative interfaces
  - Always remove event listeners in cleanup - forgotten listeners cause memory leaks and zombie animations
  - Icon animations work best when combined with subtle button scale - the icon gets more dramatic transform (translate + rotate) while button gets subtle scale
---

## [2025-01-28] - US-013
- Created src/app/patterns/card-tilt/page.tsx as the entry point for the card 3D tilt pattern
- Created src/components/patterns/card-tilt-pattern.tsx with full implementation
- Card 3D tilt pattern: calculates rotateX/rotateY based on mouse position relative to card center
- Mouse position calculation: (mouse - center) / (dimension / 2) gives -1 to 1 range
- rotateY = deltaX * maxTilt (horizontal rotation), rotateX = -deltaY * maxTilt (inverted for natural feel)
- Uses perspective: 1000px on container and transformStyle: preserve-3d on inner element
- Dynamic radial gradient shine effect that follows cursor (background-position updates on mousemove)
- Three demo cards with different maxTilt values: Product (15Â°), Profile (20Â°), Settings (10Â°)
- Elastic bounce reset on mouseleave using elastic.out(1, 0.5) easing
- Code viewer with syntax-highlighted TypeScript/JSX code
- Copy to clipboard button with scan line hover effect
- Proper cleanup: removeEventListener + gsap.killTweensOf() for both card and inner elements
- 4 key concept cards explaining: perspective, rotation axes, preserve-3d, elastic reset
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed, browser verified (matrix3d transforms confirmed in console)
- **Learnings for future iterations:**
  - For 3D tilt effects, rotateX controls vertical tilt (looking up/down), rotateY controls horizontal tilt (looking left/right)
  - The rotateX value should be inverted (-deltaY) because moving mouse down should tilt the top away (negative X rotation)
  - Perspective (1000px is a good default) determines how dramatic the 3D effect appears - lower = more dramatic
  - transformStyle: preserve-3d is required on the inner element to enable proper 3D transforms
  - radial-gradient background with dynamic position creates a convincing shine/gloss effect that follows cursor
  - matrix3d is the computed style value when 3D transforms are applied - use this to verify animations are working
  - Client-side interactive components need 'use client' directive even when imported by Server Component page

## [2025-01-28] - US-014
- Created src/app/patterns/sequential-timeline/page.tsx as the entry point for the sequential timeline pattern
- Created src/components/patterns/sequential-timeline-pattern.tsx with full implementation
- Sequential timeline pattern: uses gsap.timeline() to chain animations that play in sequence
- Live demo shows 3 shapes animating in sequence: circle scales (back.out(1.7)), square rotates (back.out(1.5)), triangle slides (power2.out)
- Timeline loops infinitely with repeat: -1 and repeatDelay: 1
- Position parameter examples: default (sequential), "-=0.1" (overlap), "+=0.1" (delay)
- Timeline flow visualization showing step-by-step animation order
- Code viewer with syntax-highlighted TypeScript/JSX code
- Copy to clipboard button with scan line hover effect
- Proper cleanup: tl.kill() and gsap.killTweensOf() for all elements
- 4 key concept cards explaining: timeline creation, chaining animations, position parameter, timeline methods
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: agent-browser skill had connection issues - manual browser verification recommended
- **Learnings for future iterations:**
  - gsap.timeline() creates a container for tweens that can be controlled as a group
  - By default, chained .to() calls play sequentially - each starts when the previous ends
  - Position parameter (3rd argument) controls timing: "-=0.1" overlaps, "+=0.1" delays, "label" syncs to labels
  - Timeline methods like .play(), .pause(), .reverse(), .restart(), .time(), .progress() allow programmatic control
  - When writing JSX code examples, always use template literals with {`{...}`} to escape curly braces
  - Using separate span elements with template literals prevents JSX parsing errors with braces

## [2025-01-28] - US-015
- Created src/app/patterns/scrub-timeline/page.tsx as the entry point for the scrub timeline pattern
- Created src/components/patterns/scrub-timeline-pattern.tsx with full implementation
- Scrub timeline pattern: timeline controlled by scroll position using ScrollTrigger scrub option
- Live demo uses gsap.timeline() with scrollTrigger config: scrub: 1 for smooth 1-second catch-up
- Three shapes animate with staggered timing: circle (scale 1.3, rotate 180, orange) at 0s, square (scale 1.2, rotate -270, x: 30, cyan) at 0.5s, triangle (scale 1.4, rotate 360, y: -20, green) at 1s
- Progress bar shows timeline progress filling from scaleX(0) to scaleX(1) over the full animation duration
- Scroll indicator with animated bounce arrow and "Scroll to animate" message
- Code viewer with syntax-highlighted TypeScript/JSX code showing scrub timeline pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: ScrollTrigger.getAll().forEach(t => t.kill()), tl.kill(), and gsap.killTweensOf() for all elements
- 3 scrub value example cards: scrub: true (instant 1:1), scrub: 1 (1s catch-up), scrub: 0.5 (0.5s more responsive)
- 4 key concept cards explaining: scrub option, timeline+ScrollTrigger, start/end position, automatic reversal
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: agent-browser skill had connection issues - manual browser verification recommended
- **Learnings for future iterations:**
  - scrub: true creates instant 1:1 scroll-to-progress link - feels direct but can feel jerky on some devices
  - scrub: 1 adds 1 second of "catch up" smoothing - the animation lags slightly behind scroll for a more polished feel
  - scrollTrigger start/end positions determine the timeline duration: the scroll distance between start and end becomes the animation timeline
  - Scrubbed timelines automatically play in reverse when scrolling up - no extra code needed
  - Position parameters in timeline still work with scrub: 0.5 starts halfway, "-=0.2" overlaps, etc.
  - ScrollTrigger.getAll().forEach(t => t.kill()) is the safest way to clean up all scroll triggers in a component
  - The progress bar animation uses ease: "none" to directly map to timeline progress without easing interference
---

## [2025-01-28] - US-016
- Created src/app/patterns/svg-draw/page.tsx as the entry point for the SVG path drawing pattern
- Created src/components/patterns/svg-draw-pattern.tsx with full implementation
- SVG path drawing pattern: uses stroke-dasharray/dashoffset technique for self-drawing paths
- Live demo uses getTotalLength() to get exact path length, then sets strokeDasharray/strokeDashoffset
- Animates strokeDashoffset from length (invisible) to 0 (fully drawn) with scrub: 1
- 4 SVG shapes: lightning bolt (orange-red gradient), star (cyan-blue gradient), spiral (purple-pink gradient), arrow (green-teal gradient)
- Code viewer with syntax-highlighted TypeScript/JSX code showing SVG drawing pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: gsap.killTweensOf(paths) and ScrollTrigger.getAll().forEach(t => t.kill()) in useGSAP return function
- 3 info cards showing: 4 Paths, Scrub: 1, Gradients
- 4 key concept cards explaining: getTotalLength, strokeDasharray, strokeDashoffset, scrub animation
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- **Learnings for future iterations:**
  - The stroke-dasharray/dashoffset technique works by setting stroke-dasharray to the path's total length and animating strokeDashoffset from length to 0
  - getTotalLength() is a method on SVGPathElement that returns the exact pixel length of any SVG path
  - Always querySelector for paths inside useGSAP to ensure the SVG is mounted before accessing DOM elements
  - scrub: 1 creates smooth scroll-linked animation with 1-second "catch up" lag for polished feel
  - Linear gradients in SVG require defining <defs> with <linearGradient> elements and referencing them via url(#id)
  - When copying pattern files as templates, rename all function/component exports to avoid naming conflicts
  - JSX template literals with `})` sequences can cause parsing issues in Turbopack - use existing working patterns as templates
---

## [2025-01-28] - US-017
- Created src/app/patterns/basic-draggable/page.tsx as the entry point for the basic draggable pattern
- Created src/components/patterns/basic-draggable-pattern.tsx with full implementation
- Updated src/lib/gsap-config.ts to register Draggable plugin
- Basic draggable pattern: 3 draggable boxes with different constraints
- Free Drag box: type: 'x,y' with no constraints - can be dragged anywhere
- Horizontal box: type: 'x' - can only be dragged left and right
- Bounded box: type: 'x,y' with bounds: containerRef - stays within parent container
- Uses Draggable.create() with options: type, edgeResistance: 0.65, bounds, cursor: 'grab', activeCursor: 'grabbing'
- Code viewer with syntax-highlighted TypeScript/JSX code showing Draggable pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: Draggable.get(element)?.kill() for each draggable element
- 3 info cards showing each drag type: Free Drag (TYPE: X,Y), Horizontal (TYPE: X), Bounded (BOUNDS: CONTAINER)
- 4 key concept cards explaining: Draggable.create, type option, bounds, cursor styles
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: agent-browser skill showed static HTML but GSAP wasn't loading in browser automation environment - manual browser verification recommended for interactive patterns
- **Learnings for future iterations:**
  - GSAP's Draggable plugin has a known case-sensitivity issue with TypeScript definitions on case-sensitive file systems (draggable.d.ts vs Draggable.js)
  - Import Draggable from 'gsap/src/Draggable' as a default export to avoid the casing conflict: `import Draggable from 'gsap/src/Draggable'`
  - Use Draggable.create(element, config) to make elements draggable - returns a Draggable instance
  - Type option controls drag direction: 'x' (horizontal), 'y' (vertical), 'x,y' (both), or 'rotation' (spinning)
  - Bounds option constrains dragging within a container: `bounds: containerRef.current` or numeric values like { minX: 0, maxX: 500 }
  - edgeResistance: 0.65 creates resistance when hitting bounds - 0 = no resistance, 1 = cannot pass bounds at all
  - Cursor styles: cursor: 'grab' for not dragging, activeCursor: 'grabbing' for dragging state
  - Use Draggable.get(element)?.kill() for cleanup - the optional chaining is necessary in case element doesn't have a Draggable instance
  - Interactive patterns like Draggable require client-side JavaScript to work - browser automation may show static HTML in some testing setups
---

## [2025-01-28] - US-018
- Created src/app/patterns/draggable-momentum/page.tsx as the entry point for the draggable momentum pattern
- Created src/components/patterns/draggable-momentum-pattern.tsx with full implementation
- Draggable momentum pattern: custom velocity tracking during drag for physics-based throw effects
- useMomentumDraggable hook implementation:
  - Tracks position changes during onDrag to calculate velocity (pixels per millisecond)
  - Stores velocity samples (max 5) and averages them for smooth, consistent momentum
  - On drag end, calculates target position: current + (velocity * 1000 * duration * 0.5)
  - Applies gsap.to() animation with duration scaled by velocity magnitude
  - Proper bounds constraint calculation for bounded throws
- Three demo boxes showing different momentum effects:
  - Free Throw (ðŸš€): Unbounded momentum with no container constraints
  - Bounded (ðŸŽ³): Bounded throw with edgeResistance: 0.9 for resistance at edges
  - Snappy (âš¡): Shorter duration (0.8s) with back.out(1.2) easing for playful bounce-back
- Code viewer with syntax-highlighted TypeScript/JSX code showing momentum drag pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: Draggable.get(element)?.kill() and gsap.killTweensOf(element) in useGSAP return function
- 4 key concept cards explaining: velocity tracking, on drag end momentum application, syncing Draggable, killing tweens
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed, browser verified with screenshot
- **Learnings for future iterations:**
  - GSAP InertiaPlugin is a PAID plugin - custom velocity tracking is required for free implementations
  - Velocity calculation: store samples of (currentPosition - lastPosition) / deltaTime and average for smoothness
  - Target position formula: current + (velocity * 1000ms * duration * 0.5) gives natural throw distance
  - Scale animation duration by velocity magnitude: duration * Math.min(totalVelocity * 20, 1) prevents slow glide on gentle throws
  - gsap.killTweensOf(element) in onDragStart is critical - prevents momentum animation from interfering with new drag
  - Draggable's x and y properties are read-only in TypeScript - don't try to assign them directly
  - When using gsap.to() on element's x/y transforms, Draggable correctly reads the computed transform on next drag without manual sync
  - JSX parsing issue: sequences like `gsap.``}` in template literals can cause parsing errors - split into separate spans or escape properly
  - For hook parameters with RefObjects, use `RefObject<HTMLDivElement | null>` to allow null values, then use optional chaining `containerRef?.current`
---

## [2025-01-28] - US-019
- Created src/app/patterns/pinned-sequence/page.tsx as the entry point for the pinned section sequence pattern
- Created src/components/patterns/pinned-sequence-pattern.tsx with full implementation
- Pinned section sequence pattern: demonstrates ScrollTrigger's pin: true option to lock sections in place during animation
- Live demo uses pin: true with end: '+=2000' to pin the section for 2000px of scroll distance
- Timeline sequence plays while section is pinned: circle scale/rotate, square scale/rotate/x-translate, triangle scale/rotate/y-translate
- Info cards (Stay Fixed, Timeline Plays, Scroll Control) reveal with stagger animation mid-sequence
- Code viewer with syntax-highlighted TypeScript/JSX code showing pinned timeline pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: ScrollTrigger.getAll().forEach(t => t.kill()), tl.kill(), and gsap.killTweensOf() for all elements
- Comparison cards showing 'With Pin' vs 'Without Pin' behavior to illustrate the value of pinning
- 4 key concept cards explaining: pin: true, end duration, pin spacer, scrub + pin combination
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: agent-browser skill had connection issues - manual browser verification recommended
- **Learnings for future iterations:**
  - pin: true locks the trigger element in place during animation, creating immersive storytelling moments
  - Use end: '+=2000' to define pin duration as scroll distance - the user scrolls that amount while section stays fixed
  - GSAP creates a "pin spacer" element to maintain document flow while the element itself becomes position: fixed
  - Combine pin with scrub for scroll-controlled animations - progress is tied to scroll within the pinned region
  - The pinned section should have sufficient content/height to justify the pin duration - match end value to content length
  - Pinning is perfect for product reveals, step-by-step guides, and narrative-driven animations
  - Cleanup is critical for pinned sections - ScrollTrigger.getAll().forEach(t => t.kill()) ensures pin spacer is removed on unmount
  - When using pin, ensure the pinned container has relative positioning and proper z-index to stay above other content
---
## [2025-01-28] - US-020
- Created src/app/patterns/count-up/page.tsx as the entry point for the count-up pattern
- Created src/components/patterns/count-up-pattern.tsx with full implementation
- Count-up animation pattern: numbers animate from 0 to target value when entering viewport
- Manual counting implementation using GSAP's onUpdate callback with proxy object { value: 0 }
- TextPlugin is a paid GSAP plugin, so this implementation uses free manual counting instead
- Proxy pattern: gsap.to(proxy, { value: target, onUpdate: () => { display.textContent = proxy.value } })
- 6 demo cards with various value formats: integers (50000+), decimals (98.5%), large numbers with commas (toLocaleString)
- CountUpCard component supports label, value, suffix, icon, gradient, and decimals props
- Uses tabular-nums class for monospaced number display to prevent jitter during counting
- power2.out easing with 2s duration creates smooth deceleration from fast to slow
- start: 'top 85%' triggers animation when card is near the bottom of viewport
- Code viewer with syntax-highlighted TypeScript/JSX code showing count-up pattern
- Copy to clipboard button with scan line hover effect and "Copied!" state feedback
- Proper cleanup: gsap.killTweensOf(proxy) in useGSAP return function
- 4 key concept cards explaining: proxy object pattern, onUpdate callback, duration control, formatting (Math.floor, toFixed, toLocaleString)
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: agent-browser skill had connection issues - manual browser verification recommended
- **Learnings for future iterations:**
  - Count-up animations work by animating a proxy object's value property, then updating the DOM in onUpdate callback
  - The tabular-nums CSS class is critical for number animations - prevents jitter when digits change width
  - Use .toFixed(decimals) for decimal numbers, Math.floor() for integers, or toLocaleString() for comma formatting
  - Duration of 2s with power2.out creates smooth, natural feeling count-ups - shorter (0.5-1s) for smaller numbers
  - Always kill tweens of the proxy object in cleanup - not the DOM element
  - The proxy object is a plain JavaScript object { value: 0 } - GSAP animates the numeric value directly
  - Each card needs its own proxy object and useGSAP hook for independent animations
  - For suffixes (+, %, etc.), append them in the onUpdate callback: display.textContent = proxy.value.toFixed(decimals) + suffix
---

## [2025-01-28] - US-021
- Created src/app/patterns/performance-optimization/page.tsx as the entry point for the performance optimization pattern
- Created src/components/patterns/performance-optimization-pattern.tsx with full implementation
- Performance optimization pattern demonstrating GPU acceleration techniques for 60fps animations
- Live demo with side-by-side comparison: will-change vs no will-change animations
- Shows GPU-accelerated properties: transform (translate, scale, rotate), opacity, filter
- Will-change hint explanation and when to use it (sparingly, only on animating elements)
- Code viewer with syntax-highlighted TypeScript/JSX code showing optimized animation pattern
- Do's and Don'ts section with code examples: transform vs top/left, opacity vs visibility, will-change specifics
- 4 key concept cards covering GPU acceleration, will-change hints, avoiding layout properties, forcing GPU layers
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: dev server had connection issues for browser verification - manual testing recommended
- **Learnings for future iterations:**
  - GPU-accelerated properties (transform, opacity, filter) run on the GPU and avoid layout recalculations
  - Layout properties (width, height, top, left, margin, padding) trigger CPU-bound layout recalculation - avoid for animations
  - will-change is a hint to the browser to optimize for upcoming changes - use sparingly only on elements that will actually animate
  - transform: translateZ(0) or Tailwind's transform-gpu forces a GPU layer - use sparingly as each layer consumes GPU memory
  - For will-change in Tailwind, use: will-change-transform, will-change-opacity, will-change-transform,opacity
  - The key performance pattern: Animate only transform and opacity properties for 60fps animations
  - Be specific with will-change - "will-change: all" wastes resources, use "will-change: transform, opacity" instead
  - Performance optimization is critical for smooth user experience - users notice the difference between 30fps and 60fps

## [2025-01-28] - US-022
- Created src/app/patterns/reduced-motion/page.tsx as the entry point for reduced motion pattern
- Created src/components/patterns/reduced-motion-pattern.tsx with full implementation
- Reduced motion pattern: uses gsap.matchMedia() to conditionally create animations based on (prefers-reduced-motion: no-preference) and (prefers-reduced-motion: reduce)
- Full motion mode: gsap.set() for initial state (opacity: 0, y: 80, scale: 0.9) then gsap.to() with stagger: 0.15 and back.out(1.2) easing
- Reduced motion mode: gsap.set() immediately sets final state (opacity: 1, y: 0, scale: 1) - no animation
- Live demo includes toggle button to simulate reduced motion mode for demonstration purposes
- Visual mode indicator shows "Full Motion Mode" (orange) or "Reduced Motion Mode" (emerald) with pulse animation
- Code viewer with syntax-highlighted TypeScript/JSX code showing matchMedia pattern
- System Preferences Info section with instructions for Windows, macOS, iOS, and Android
- Key concepts cards: matchMedia(), prefers-reduced-motion, immediate state, cleanup (mm.kill())
- Accessibility note explaining vestibular disorders and importance of motion preferences
- Follows same industrial orange design system: zinc-950 background, zinc-900 cards, orange-500 accents
- Build and typecheck passed
- Note: agent-browser skill had connection issues - manual browser verification recommended
- **Learnings for future iterations:**
  - gsap.matchMedia() is the correct way to handle conditional animations based on CSS media queries
  - MatchMedia contexts must be killed with mm.kill() in cleanup to prevent memory leaks
  - For reduced motion, use gsap.set() to immediately place elements in final state - no gsap.to() animation
  - The matchMedia add() method takes a media query string and a callback function that runs when condition matches
  - "(prefers-reduced-motion: reduce)" is set at OS level - affects all websites for users with motion sensitivity
  - Simulation toggle is useful for demo purposes, but in production use the actual system preference
  - matchMedia contexts can be layered with multiple .add() calls for different conditions
  - The matchMedia callback receives a context parameter for additional control if needed
  - Always cleanup mm.kill() before ScrollTrigger cleanup to ensure proper disposal order
